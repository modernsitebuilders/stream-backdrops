// find-undefined-href.js - Find the exact source of the undefined href error
// Run with: node find-undefined-href.js

const fs = require('fs');
const path = require('path');

function findUndefinedHref() {
  console.log('ðŸ” Searching for the source of undefined href error...\n');
  
  // Search all JS/JSX files recursively
  function searchAllFiles(dir, results = []) {
    if (!fs.existsSync(dir)) return results;
    
    const items = fs.readdirSync(dir);
    items.forEach(item => {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory() && !item.startsWith('.') && item !== 'node_modules') {
        searchAllFiles(fullPath, results);
      } else if (item.endsWith('.js') || item.endsWith('.jsx') || item.endsWith('.ts') || item.endsWith('.tsx')) {
        results.push(fullPath);
      }
    });
    return results;
  }
  
  const allFiles = searchAllFiles(__dirname);
  console.log(`ðŸ“ Searching ${allFiles.length} files for undefined href patterns...\n`);
  
  let foundIssues = [];
  
  allFiles.forEach(filePath => {
    const relativePath = filePath.replace(__dirname + '\\', '');
    
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      
      // Look for various patterns that could cause undefined href
      const patterns = [
        { name: 'href={undefined}', regex: /href=\{undefined\}/g },
        { name: 'href={}', regex: /href=\{\}/g },
        { name: 'href=""', regex: /href=""/g },
        { name: "href=''", regex: /href=''/g },
        { name: 'href={someVar} where someVar might be undefined', regex: /href=\{[^}]+\}/g },
        { name: 'Link without href', regex: /<Link(?![^>]*href)[^>]*>/g },
        { name: 'premium references', regex: /premium/gi }
      ];
      
      patterns.forEach(({ name, regex }) => {
        const matches = content.match(regex);
        if (matches) {
          // For href={someVar}, let's check what that variable might be
          if (name.includes('someVar')) {
            matches.forEach(match => {
              const varName = match.match(/href=\{([^}]+)\}/)[1];
              // Check if this variable is defined in the same file
              if (!content.includes(`const ${varName}`) && !content.includes(`let ${varName}`) && !content.includes(`var ${varName}`) && !content.includes(`${varName} =`)) {
                foundIssues.push({
                  file: relativePath,
                  pattern: name,
                  match: match,
                  line: getLineNumber(content, match)
                });
              }
            });
          } else {
            matches.forEach(match => {
              foundIssues.push({
                file: relativePath,
                pattern: name,
                match: match,
                line: getLineNumber(content, match)
              });
            });
          }
        }
      });
      
      // Also look for specific components that might be causing issues
      const lines = content.split('\n');
      lines.forEach((line, index) => {
        if (line.includes('<Link') && !line.includes('href=')) {
          foundIssues.push({
            file: relativePath,
            pattern: 'Link component without href',
            match: line.trim(),
            line: index + 1
          });
        }
      });
      
    } catch (error) {
      // Skip files that can't be read
    }
  });
  
  if (foundIssues.length > 0) {
    console.log(`ðŸš¨ Found ${foundIssues.length} potential issues:\n`);
    
    foundIssues.forEach(({ file, pattern, match, line }) => {
      console.log(`ðŸ“ ${file}:${line}`);
      console.log(`   Pattern: ${pattern}`);
      console.log(`   Code: ${match}`);
      console.log('');
    });
    
    // Create a fix for the most common issues
    console.log('ðŸ”§ Creating targeted fixes...\n');
    
    const filesToFix = [...new Set(foundIssues.map(issue => issue.file))];
    
    filesToFix.forEach(relativePath => {
      const fullPath = path.join(__dirname, relativePath);
      let content = fs.readFileSync(fullPath, 'utf8');
      let changed = false;
      
      const fileIssues = foundIssues.filter(issue => issue.file === relativePath);
      
      fileIssues.forEach(({ pattern, match }) => {
        if (pattern.includes('undefined') || pattern.includes('{}') || pattern.includes('""') || pattern.includes("''")) {
          // Replace with safe href
          const safeReplacement = match.replace(/href=\{[^}]*\}|href=""|href=''/, 'href="#"');
          content = content.replace(match, safeReplacement);
          changed = true;
          console.log(`   âœ… ${relativePath}: Fixed ${match} -> ${safeReplacement}`);
        } else if (pattern.includes('without href')) {
          // Add href="#" to Link components without href
          const fixedMatch = match.replace('<Link', '<Link href="#"');
          content = content.replace(match, fixedMatch);
          changed = true;
          console.log(`   âœ… ${relativePath}: Added href to Link component`);
        }
      });
      
      if (changed) {
        // Backup first
        if (!fs.existsSync(fullPath + '.backup')) {
          fs.copyFileSync(fullPath, fullPath + '.backup');
        }
        fs.writeFileSync(fullPath, content);
        console.log(`   ðŸ’¾ Updated ${relativePath}`);
      }
    });
    
    console.log('\nðŸŽ‰ Applied fixes! Restart your dev server.');
    
  } else {
    console.log('âœ… No obvious undefined href patterns found in files.');
    console.log('\nðŸ’¡ The error might be coming from:');
    console.log('1. Dynamic href values that become undefined at runtime');
    console.log('2. Props passed to components that become undefined'); 
    console.log('3. State variables used in href that are undefined');
    console.log('\nCheck your browser console - it should show the exact component causing the error.');
  }
}

function getLineNumber(content, searchText) {
  const lines = content.split('\n');
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].includes(searchText)) {
      return i + 1;
    }
  }
  return 'unknown';
}

findUndefinedHref();